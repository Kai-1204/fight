<!doctype html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>火柴人對打（手機版・技能＆超慢版）</title>
<style>
  :root {
    --bg:#0d0f12; --panel:#11151a; --ink:#eaeef3; --sub:#9aa4af; --p1:#5aa0ff; --p2:#ff6b6b; --accent:#ffd166;
  }
  * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
  html, body { height:100%; }
  body {
    margin:0; background: linear-gradient(180deg, #0e1217, #151a21);
    color:var(--ink); font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans TC", "PingFang TC", "Heiti TC", Arial, sans-serif;
    overflow:hidden;
  }
  #wrap { position:relative; width:100vw; height:100vh; }
  canvas { position:absolute; inset:0; width:100%; height:100%; display:block; touch-action:none; }
  /* HUD */
  .hud { position:absolute; top:10px; left:0; right:0; display:flex; justify-content:space-between; gap:10px; padding:0 12px; pointer-events:none; }
  .bar { width:42vw; max-width:520px; height:18px; background:#2a2f36; border:1px solid #3a414b; border-radius:10px; position:relative; overflow:hidden; }
  .bar .slow { position:absolute; inset:0; width:100%; height:100%; background:linear-gradient(90deg,#7a2f2f,#4a2020); transform-origin:left; }
  .bar .fast { position:absolute; inset:0; width:100%; height:100%; background:linear-gradient(90deg,var(--p1),#6bd1ff); transform-origin:left; }
  .bar.enemy .fast { background:linear-gradient(90deg,var(--p2),#ff9aa6); }
  .labels { position:absolute; top:-22px; display:flex; gap:8px; font-size:14px; color:var(--sub); }
  .meta { position:absolute; top:10px; left:50%; transform:translateX(-50%); font-weight:600; font-size:14px; color:var(--sub); text-shadow:0 1px 0 #000; pointer-events:none; white-space:nowrap; }
  .centerMsg { position:absolute; top:35%; left:50%; transform:translate(-50%,-50%); text-align:center; z-index:5; }
  .centerMsg h1 { margin:0 0 10px; font-size:34px; letter-spacing:1px; }
  .centerMsg p { margin:6px 0; color:var(--sub); }
  .btnRow { margin-top:14px; display:flex; gap:10px; justify-content:center; flex-wrap:wrap; }
  .uiBtn {
    appearance:none; border:none; border-radius:12px; padding:10px 14px;
    background:var(--panel); color:var(--ink); font-weight:600; letter-spacing:0.5px;
    box-shadow:0 6px 20px rgba(0,0,0,.25), inset 0 0 0 1px #2b313a; cursor:pointer;
  }
  .uiBtn:active { transform: translateY(1px); }
  .gear { position:absolute; top:10px; right:12px; z-index:6; pointer-events:auto; }
  .gear .uiBtn { padding:8px 10px; font-size:14px; }
  /* Touch controls */
  .controls { position:absolute; inset:auto 0 14px 0; display:flex; justify-content:space-between; padding:0 14px; gap:14px; z-index:2; }
  .pad { display:flex; gap:10px; }
  .btn {
    width:72px; height:72px; border-radius:20px; background:rgba(255,255,255,.06);
    box-shadow: inset 0 0 0 2px rgba(255,255,255,.08), 0 8px 24px rgba(0,0,0,.35);
    display:grid; place-items:center; color:#cfd6df; font-weight:700; user-select:none;
  }
  .btn:active, .btn.active { background:rgba(255,255,255,.12); transform: translateY(2px); }
  .btn.big { width:86px; height:86px; font-size:18px; }
  .btn.skill { outline: 2px solid rgba(255,255,255,.12); }
  .btn.skill.cd { filter: grayscale(1); opacity: .6; }
  .hint { position:absolute; left:50%; bottom:110px; transform:translateX(-50%); color:var(--sub); font-size:12px; opacity:.8; }
  @media (min-width: 900px) {
    .btn { width:64px; height:64px; }
    .btn.big { width:76px; height:76px; }
  }
</style>
</head>
<body>
  <div id="wrap">
    <canvas id="game"></canvas>

    <div class="hud">
      <div class="bar player">
        <div class="slow" id="pSlow" style="transform:scaleX(1)"></div>
        <div class="fast" id="pFast" style="transform:scaleX(1)"></div>
        <div class="labels" style="left:8px"><span>PLAYER</span></div>
      </div>
      <div class="bar enemy">
        <div class="slow" id="eSlow" style="transform:scaleX(1)"></div>
        <div class="fast" id="eFast" style="transform:scaleX(1)"></div>
        <div class="labels" style="right:8px"><span>ENEMY</span></div>
      </div>
      <div class="meta" id="metaTxt">CRIT 12%｜技能CD 0.0s</div>
    </div>

    <div class="gear"><button class="uiBtn" id="openMenu">⚙️ 難度</button></div>

    <!-- 開始／難度選單 -->
    <div class="centerMsg" id="menu">
      <h1>選擇難度</h1>
      <p>已<strong>再度降低</strong>移動、出拳與傷害；「不能連擊」：一次出拳只會判定一次。</p>
      <div class="btnRow">
        <button class="uiBtn" data-diff="Easy">簡單</button>
        <button class="uiBtn" data-diff="Normal">普通</button>
        <button class="uiBtn" data-diff="Hard">困難</button>
      </div>
      <p style="font-size:12px;color:#9aa4af;margin-top:10px;">右上角⚙️可隨時調整；技能鍵：K 或「技」</p>
    </div>

    <!-- 結束畫面 -->
    <div class="centerMsg" id="center" style="display:none;">
      <h1 id="banner">你贏了！</h1>
      <p>點擊下方按鈕重新開始</p>
      <div class="btnRow">
        <button class="uiBtn" id="restartBtn">重新開始</button>
      </div>
    </div>

    <div class="hint">手機：← → 跳 打 技｜電腦：A/D/W/J/K（K為1秒無敵）</div>

    <div class="controls" id="controls">
      <div class="pad">
        <div class="btn" data-key="Left" id="btnLeft">←</div>
        <div class="btn" data-key="Right" id="btnRight">→</div>
      </div>
      <div class="pad">
        <div class="btn big" data-key="Jump" id="btnJump">跳</div>
        <div class="btn big" data-key="Punch" id="btnPunch">打</div>
        <div class="btn big skill" data-key="Skill" id="btnSkill">技</div>
      </div>
    </div>
  </div>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));

  // Size & resize
  function fit() {
    const w = canvas.clientWidth, h = canvas.clientHeight;
    canvas.width = Math.round(w * DPR);
    canvas.height = Math.round(h * DPR);
    ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
  }
  new ResizeObserver(fit).observe(canvas);
  fit();

  // Utils
  const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));
  const lerp = (a,b,t) => a + (b-a)*t;
  const rand = (a,b) => a + Math.random()*(b-a);
  const TWO_PI = Math.PI * 2;

  // Base config (even lower)
  const BASE = {
    speed: 2.0,           // 再降低移動速度
    jumpV: -12.5,
    attackTotal: 32,      // 出拳更慢
    attackCool: 42,       // 冷卻更長，不能亂按
    dmgNormal: 2,         // 傷害再降
    dmgCrit: 6,           // 爆擊傷害再降
    critPlayer: 0.12,     // 爆擊機率 12%
    skillInvulnSec: 1.0,  // 無敵 1 秒
    skillCooldownSec: 8.0 // 技能冷卻 8 秒
  };

  // Difficulty presets (影響敵人表現)
  const DIFF = {
    Easy:   { name:'簡單',  enemy:{ speedMul:0.85, dmgMul:0.8,  crit:0.06, attackCoolMul:1.2 } },
    Normal: { name:'普通',  enemy:{ speedMul:1.0,  dmgMul:1.0,  crit:0.10, attackCoolMul:1.0 } },
    Hard:   { name:'困難', enemy:{ speedMul:1.2,  dmgMul:1.25, crit:0.16, attackCoolMul:0.9 } }
  };

  let currentDiff = 'Normal';
  let cfg = DIFF[currentDiff];

  // World
  let W = () => canvas.clientWidth;
  let H = () => canvas.clientHeight;
  const GROUND_OFFSET = 90; // px from bottom
  const groundY = () => H() - GROUND_OFFSET;

  // Input (keyboard + touch)
  const keys = { Left:false, Right:false, Jump:false, Punch:false, Skill:false };
  const keyMap = { 'a':'Left', 'd':'Right', 'ArrowLeft':'Left', 'ArrowRight':'Right', 'w':'Jump', 'W':'Jump', ' ':'Jump', 'j':'Punch', 'J':'Punch', 'k':'Skill', 'K':'Skill' };
  window.addEventListener('keydown', e => { const k = keyMap[e.key]; if (k){ keys[k]=true; if(['ArrowLeft','ArrowRight',' '].includes(e.key)) e.preventDefault(); } });
  window.addEventListener('keyup', e => { const k = keyMap[e.key]; if (k){ keys[k]=false; } });

  // Touch buttons
  const activeTouches = new Map(); // id -> key
  function press(k){ keys[k]=true; document.querySelector(`[data-key="${k}"]`)?.classList.add('active'); }
  function release(k){ keys[k]=false; document.querySelector(`[data-key="${k}"]`)?.classList.remove('active'); }
  function handleTouchStart(e){
    for(const t of e.changedTouches){
      const el = document.elementFromPoint(t.clientX, t.clientY);
      const key = el?.getAttribute?.('data-key');
      if(key){ activeTouches.set(t.identifier, key); press(key); }
    }
    e.preventDefault();
  }
  function handleTouchEnd(e){
    for(const t of e.changedTouches){
      const key = activeTouches.get(t.identifier);
      if(key){ release(key); activeTouches.delete(t.identifier); }
    }
    e.preventDefault();
  }
  function handleTouchMove(e){
    for(const t of e.changedTouches){
      const oldKey = activeTouches.get(t.identifier);
      const el = document.elementFromPoint(t.clientX, t.clientY);
      const newKey = el?.getAttribute?.('data-key');
      if(newKey !== oldKey){
        if(oldKey) release(oldKey);
        if(newKey){ press(newKey); activeTouches.set(t.identifier, newKey); }
        else activeTouches.delete(t.identifier);
      }
    }
    e.preventDefault();
  }
  const controls = document.getElementById('controls');
  controls.addEventListener('touchstart', handleTouchStart, {passive:false});
  controls.addEventListener('touchend', handleTouchEnd, {passive:false});
  controls.addEventListener('touchcancel', handleTouchEnd, {passive:false});
  controls.addEventListener('touchmove', handleTouchMove, {passive:false});

  // HUD refs
  const pSlow = document.getElementById('pSlow'), pFast = document.getElementById('pFast');
  const eSlow = document.getElementById('eSlow'), eFast = document.getElementById('eFast');
  const metaTxt = document.getElementById('metaTxt');
  const btnSkill = document.getElementById('btnSkill');

  // Entities
  class Particle {
    constructor(x,y,vx,vy,life,size,color){
      Object.assign(this, {x,y,vx,vy,life,maxLife:life,size,color});
    }
    update(){
      this.x += this.vx;
      this.y += this.vy;
      this.vy += 0.15;
      this.life--;
    }
    draw(shake){
      if(this.life<=0) return;
      const a = this.life/this.maxLife;
      ctx.save();
      ctx.globalAlpha = a;
      ctx.fillStyle = this.color;
      ctx.beginPath();
      ctx.arc(this.x+shake.x, this.y+shake.y, this.size, 0, TWO_PI);
      ctx.fill();
      ctx.restore();
    }
  }

  class FloatText {
    constructor(text,x,y,color,life=40){
      Object.assign(this,{text,x,y,color,life});
    }
    update(){ this.y -= 0.6; this.life--; }
    draw(shake){
      if(this.life<=0) return;
      ctx.save();
      ctx.globalAlpha = this.life/40;
      ctx.fillStyle = this.color;
      ctx.font = '16px system-ui';
      ctx.fillText(this.text, this.x+shake.x, this.y+shake.y);
      ctx.restore();
    }
  }

  class Stickman {
    constructor(x,color,isPlayer=true){
      this.x=x; this.y=groundY();
      this.vx=0; this.vy=0; this.onGround=true;
      this.facing=1; this.color=color; this.isPlayer=isPlayer;
      this.hp=100; this.hpDraw=100;
      this.attackCool=0; this.attackAnim=0;
      this.attackActiveStart=10; this.attackActiveEnd=18; // 對應更慢的總幀
      this.attackTotal=BASE.attackTotal;
      this.stun=0;
      // 防多段（不能連擊）：每次出拳只吃一次命中
      this.hitUsed=false;

      // 技能：無敵
      this.invulnTimer=0;        // ms
      this.skillCd = 0;          // ms
      this.skillCdTotal = BASE.skillCooldownSec*1000;
      this.skillInvuln = BASE.skillInvulnSec*1000;
    }
    bodyTop(){ return {x:this.x, y:this.y-40}; }
    update(input,target,dt){
      const baseSpeed = BASE.speed;
      const speedMul = this.isPlayer ? 1.0 : cfg.enemy.speedMul;
      const speed = (this.stun?0.5:1) * baseSpeed * speedMul;
      const jumpV = BASE.jumpV;

      if(this.isPlayer){
        this.vx = 0;
        if(input.Left){ this.vx = -speed; this.facing=-1; }
        if(input.Right){ this.vx = speed; this.facing= 1; }
        if(input.Jump && this.onGround && !this.stun){ this.vy = jumpV; this.onGround=false; }
        if(input.Punch && this.attackCool===0 && !this.stun){ this.startAttack(); }
        if(input.Skill){ this.trySkill(); }
      }else{
        // Simple AI
        if(target){
          const dx = target.x - this.x;
          if(Math.abs(dx) > 55){ this.vx = speed * (dx>0?1:-1); this.facing = dx>0?1:-1; }
          else this.vx = 0;
          if(this.onGround && Math.random()<0.006) { this.vy = jumpV; this.onGround=false; }
          if(Math.abs(dx) < 65 && this.attackCool===0 && !this.stun){ this.startAttack(); }
        }
      }

      // Physics
      this.x += this.vx;
      this.y += this.vy;
      if(!this.onGround){
        this.vy += 0.65;
        if(this.y >= groundY()){
          this.y = groundY(); this.vy=0; this.onGround=true;
        }
      }
      this.x = clamp(this.x, 40, W()-40);

      if(this.attackCool>0) this.attackCool--;
      if(this.attackAnim>0) this.attackAnim--;
      if(this.stun>0) this.stun--;

      // 計時（技能）
      if(this.invulnTimer>0) this.invulnTimer = Math.max(0, this.invulnTimer - dt);
      if(this.skillCd>0) this.skillCd = Math.max(0, this.skillCd - dt);

      this.hpDraw = lerp(this.hpDraw, this.hp, 0.12);
    }
    startAttack(){
      const mul = this.isPlayer ? 1.0 : cfg.enemy.attackCoolMul;
      this.attackCool = Math.round(BASE.attackCool * mul);
      this.attackAnim = this.attackTotal;
      this.hitUsed = false; // 重置本次出拳的命中權
    }
    isActive(){
      const f = this.attackTotal - this.attackAnim;
      return this.attackActiveStart <= f && f <= this.attackActiveEnd;
    }
    fistPos(){
      const t = clamp((this.attackTotal - this.attackAnim)/this.attackTotal, 0, 1);
      const angleDeg = (this.facing===1) ? (40 + ( -70 * t)) : (140 + (70 * t));
      const rad = angleDeg * Math.PI/180;
      const L = 34;
      const base = this.bodyTop();
      return { x: base.x + Math.cos(rad)*L, y: base.y + Math.sin(rad)*L };
    }
    trySkill(){
      if(this.skillCd<=0){
        this.invulnTimer = this.skillInvuln;
        this.skillCd = this.skillCdTotal;
        // 小特效：身邊閃光
        for(let i=0;i<18;i++){
          const ang = rand(0,TWO_PI);
          const sp = rand(1.5,3.5);
          particles.push(new Particle(this.x, this.y-40, Math.cos(ang)*sp, Math.sin(ang)*sp, Math.round(rand(16,26)), rand(1.6,2.8), '#a9f2ff'));
        }
        texts.push(new FloatText('無敵！', this.x, this.y-60, '#a9f2ff', 40));
        // 按鈕狀態
        btnSkill.classList.add('cd');
      }
    }
    isInvuln(){ return this.invulnTimer>0; }
    draw(shake){
      const x = this.x+shake.x, y=this.y+shake.y;
      ctx.lineWidth = 5;
      ctx.strokeStyle = this.color;
      ctx.fillStyle = this.color;

      // 如果無敵，畫一個淡藍色外框光暈
      if(this.isInvuln()){
        ctx.save();
        ctx.globalAlpha = 0.35;
        ctx.strokeStyle = '#9be8ff';
        ctx.lineWidth = 8;
        ctx.beginPath(); ctx.moveTo(x, y-40); ctx.lineTo(x, y); ctx.stroke();
        ctx.beginPath(); ctx.arc(x, y-55, 14, 0, TWO_PI); ctx.stroke();
        ctx.restore();
      }

      // body
      ctx.beginPath();
      ctx.moveTo(x, y-40); ctx.lineTo(x, y);
      ctx.stroke();
      // head
      ctx.beginPath(); ctx.arc(x, y-55, 11, 0, TWO_PI); ctx.stroke();
      // legs
      ctx.beginPath();
      ctx.moveTo(x, y); ctx.lineTo(x-14, y+22);
      ctx.moveTo(x, y); ctx.lineTo(x+14, y+22);
      ctx.stroke();
      // idle arm
      ctx.beginPath();
      ctx.moveTo(x, y-30); ctx.lineTo(x-16, y-12); ctx.stroke();

      // attack arm
      const f = this.fistPos();
      ctx.beginPath();
      ctx.moveTo(x, y-30); ctx.lineTo(f.x+shake.x, f.y+shake.y);
      ctx.stroke();
      ctx.beginPath();
      ctx.arc(f.x+shake.x, f.y+shake.y, 3.6, 0, TWO_PI);
      ctx.fill();
    }
  }

  // Hit detection & FX
  const particles = [];
  const texts = [];
  function addHitFX(x,y,isCrit){
    const n = isCrit? 18 : 10;
    for(let i=0;i<n;i++){
      const ang = rand(0,TWO_PI);
      const spd = isCrit? rand(2,4.2) : rand(1.2,3.0);
      particles.push(new Particle(x,y,Math.cos(ang)*spd,Math.sin(ang)*spd, Math.round(rand(14,22)), Math.round(rand(1.4,2.6)), isCrit ? '#ffb14a' : '#b8c2cc'));
    }
  }

  function checkHit(attacker, defender){
    if(!attacker.isActive() || attacker.hitUsed) return {dmg:0, crit:false, hit:false}; // 每次出拳只判一次
    const f = attacker.fistPos();
    const dx = defender.x - f.x;
    const dy = (defender.y-40) - f.y;
    const dist = Math.hypot(dx, dy);
    if(dist < 28){
      // 無敵判定
      if(defender.isInvuln()) {
        texts.push(new FloatText('MISS', f.x, f.y-18, '#9aa4af', 28));
        attacker.hitUsed = true; // 即便無敵也算消耗本次攻擊判定
        return {dmg:0, crit:false, hit:false};
      }
      const critChance = attacker.isPlayer ? BASE.critPlayer : cfg.enemy.crit;
      const crit = Math.random() < critChance;
      let dmg = crit ? BASE.dmgCrit : BASE.dmgNormal;
      if(!attacker.isPlayer) dmg *= cfg.enemy.dmgMul; // 敵人依難度加成
      defender.hp = clamp(defender.hp - dmg, 0, 100);
      defender.stun = crit ? 10 : 6;
      addHitFX(f.x, f.y, crit);
      texts.push(new FloatText(crit? `CRIT! -${Math.round(dmg)}` : `-${Math.round(dmg)}`, f.x, f.y-18, crit? '#ff5252' : '#e6edf3'));
      attacker.hitUsed = true; // 消耗命中權
      return {dmg, crit, hit:true, x:f.x, y:f.y};
    }
    return {dmg:0, crit:false, hit:false};
  }

  // Game state
  let player, enemy, state, winner, shakeT=0, shakePow=0;
  const center = document.getElementById('center');
  const banner = document.getElementById('banner');

  const menu = document.getElementById('menu');
  const openMenu = document.getElementById('openMenu');
  document.querySelectorAll('#menu .uiBtn[data-diff]').forEach(btn => {
    btn.addEventListener('click', () => {
      currentDiff = btn.dataset.diff;
      cfg = DIFF[currentDiff];
      reset();
      menu.style.display = 'none';
    });
  });
  openMenu.addEventListener('click', () => {
    menu.style.display = 'block';
    state = 'menu';
  });

  function reset(){
    player = new Stickman(W()*0.28, '#5aa0ff', true);
    enemy  = new Stickman(W()*0.72, '#ff6b6b', false);
    state='playing'; winner='';
    particles.length=0; texts.length=0;
    shakeT=0; shakePow=0;
    metaTxt.textContent = `CRIT ${Math.round(BASE.critPlayer*100)}%｜技能CD 0.0s｜難度：${DIFF[currentDiff].name}`;
    center.style.display='none';
    btnSkill.classList.remove('cd');
  }

  function startAtMenu() {
    menu.style.display = 'block';
    state = 'menu';
  }

  document.getElementById('restartBtn').addEventListener('click', reset);
  canvas.addEventListener('click', () => { if(state!=='playing' && menu.style.display==='none') reset(); });

  // Start in menu
  startAtMenu();

  // Main loop
  let last = performance.now();
  function loop(now){
    requestAnimationFrame(loop);
    const dt = Math.min(50, now - last); last = now;

    if(state==='playing'){
      player.update(keys, enemy, dt);
      enemy.update({}, player, dt);

      // hits
      const h1 = checkHit(player, enemy);
      if(h1.hit){ shakeT = h1.crit? 8 : 4; shakePow = h1.crit? 7 : 4; }
      const h2 = checkHit(enemy, player);
      if(h2.hit){ shakeT = h2.crit? 8 : 4; shakePow = h2.crit? 7 : 4; }

      // particles & texts
      for(let i=particles.length-1;i>=0;i--){ particles[i].update(); if(particles[i].life<=0) particles.splice(i,1); }
      for(let i=texts.length-1;i>=0;i--){ texts[i].update(); if(texts[i].life<=0) texts.splice(i,1); }

      // shake
      if(shakeT>0) shakeT--;

      // win check
      if(player.hp<=0 || enemy.hp<=0){
        state='gameover';
        winner = (enemy.hp<=0 && player.hp>0) ? '你贏了！' : (player.hp<=0 && enemy.hp>0) ? '你輸了…' : '平手';
        banner.textContent = `${winner}（${DIFF[currentDiff].name}）`;
        center.style.display = 'block';
      }
    }

    // draw
    ctx.clearRect(0,0,W(),H());

    // ground
    ctx.strokeStyle = '#2b313a';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(0, groundY()+2);
    ctx.lineTo(W(), groundY()+2);
    ctx.stroke();

    // shake vector
    const shake = (shakeT>0) ? { x: (Math.random()*2-1)*shakePow, y: (Math.random()*2-1)*shakePow } : {x:0,y:0};

    // health bars
    const pRatioTrue = clamp(player.hp/100,0,1);
    const pRatioDraw = clamp(player.hpDraw/100,0,1);
    const eRatioTrue = clamp(enemy.hp/100,0,1);
    const eRatioDraw = clamp(enemy.hpDraw/100,0,1);
    pFast.style.transform = `scaleX(${pRatioTrue.toFixed(3)})`;
    pSlow.style.transform = `scaleX(${pRatioDraw.toFixed(3)})`;
    eFast.style.transform = `scaleX(${eRatioTrue.toFixed(3)})`;
    eSlow.style.transform = `scaleX(${eRatioDraw.toFixed(3)})`;

    // actors & fx
    if(state!=='menu'){
      player.draw(shake);
      enemy.draw(shake);
      particles.forEach(p=>p.draw(shake));
      texts.forEach(t=>t.draw(shake));
    }

    // HUD meta（技能CD）
    const cdSec = Math.max(0, player.skillCd/1000);
    metaTxt.textContent = `CRIT ${Math.round(BASE.critPlayer*100)}%｜技能CD ${cdSec.toFixed(1)}s｜難度：${DIFF[currentDiff].name}`;
    if(player.skillCd<=0) btnSkill.classList.remove('cd'); else btnSkill.classList.add('cd');
  }
  requestAnimationFrame(loop);

  // Prevent scroll on space/arrow
  window.addEventListener('keydown', e => {
    if([' ', 'ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.key)) e.preventDefault();
  }, {passive:false});
})();</script>
</body>
</html>
